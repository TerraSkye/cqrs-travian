package domain

import (
	"context"
	"cqrs-travian/world/domain/commands"
	"cqrs-travian/world/events"
	"cqrs-travian/world/support"
	"fmt"
	"github.com/google/uuid"
	cqrs "github.com/terraskye/eventsourcing"
	"math"
	"time"
)

type Village struct {
	*cqrs.AggregateBase
	celebrationOngoing bool
	capacity           [2]int64
	resources          support.Resources
	production         [4]time.Duration
	levels             [40]int
	building           [40]support.BuildingType
	Tribe              support.Tribe
	SetlerCount        int8
	//ResearchQueue
	Queue []any

	ConcurrentConstructionsAllowed int
}

func (v *Village) EstablishVillage(ctx context.Context, cmd *commands.EstablishVillageCommand) error {
	//To be able to settle a new village, you need these:

	//Culture Points, generated by all buildings
	//3 settlers
	//750 wood, clay, iron and crop
	// need a rallypoint

	// need 3 setlers
	// needs resources
	// tile needs to be available

	if v.resources.Has(750, 750, 750, 750) {

	}

}

func (v *Village) InitiateBuildingConstruction(ctx context.Context, cmd *commands.UpgradeExistingBuildingCommand) error {

	//todo check if there is enough resources available.

	v.AppendEvent(&events.BuildingConstructionInitiatedEvent{
		WorldID:         cmd.WorldID,
		VillageID:       0,
		BuildingID:      0,
		Wood:            0,
		Clay:            0,
		Iron:            0,
		Crop:            0,
		CropConsumption: 0,
		CulturePoint:    0,
		Duration:        0,
	})

	return nil
}

func (v *Village) UpgradeExistingField(ctx context.Context, cmd *commands.UpgradeExistingFieldCommand) error {

	//check resource
	//check queue

	//todod add to queue

	//todo check if there is enough resources available.

	if len(v.Queue) {

	}

	v.AppendEvent(&events.FieldUpgradeStartedEvent{
		WorldID:      cmd.WorldID,
		VillageID:    cmd.VillageID,
		UpgradeID:    uuid.New(),
		TileID:       cmd.FieldID,
		CropConsumption:,
		CulturePoint: 0,
	})

	return nil
}

func (v *Village) Celebrate(ctx context.Context, cmd *commands.StartCelebrationCommand) error {

	if v.celebrationOngoing {
		return fmt.Errorf("there already is a celebration on going")
	}

	var townHallLevel int

	for fieldID, building := range v.building {
		if building == support.TownHall {
			townHallLevel = v.levels[fieldID]
			break
		}
	}

	if townHallLevel == 0 {
		return fmt.Errorf("townhall is required to start a celebration")
	}

	var celebrationDuration time.Duration

	if !cmd.Large {
		if !v.resources.Has(6400, 6650, 5940, 1340) {
			return fmt.Errorf("insufficient resources for a small celebration")
		}

		baseTime := 24 * 3600 // 24 hours in seconds
		timeInSeconds := float64(baseTime) * math.Pow(0.964, float64(townHallLevel-1))
		celebrationDuration = time.Duration(timeInSeconds) * time.Second

	} else {
		if townHallLevel < 10 {
			return fmt.Errorf("townhall of level 10 is required to start a large celebration")
		}
		if !v.resources.Has(29700, 33250, 32000, 6700) {
			return fmt.Errorf("insufficient resources for a large celebration")
		}

		baseTime := 60 * 3600 // 60 hours in seconds
		timeInSeconds := float64(baseTime) * math.Pow(0.964, float64(townHallLevel-1))
		celebrationDuration = time.Duration(timeInSeconds) * time.Second

	}

	// calculate the duration of the celebration.

	v.AppendEvent(&events.CelebrationStartedEvent{
		WorldID:   cmd.WorldID,
		VillageID: cmd.VillageID,
		Large:     cmd.Large,
		Duration:  celebrationDuration,
	})

	return nil
}

func (v *Village) OnFieldUpgradedStarted(event *events.FieldUpgradedStartedEvent) {
	v.Queue[]
}
func (v *Village) OnFieldUpgradedFinished(event *events.FieldUpgradedFinishedEvent) {

}
func (v *Village) OnFieldUpgradedCancelled(event *events.FieldUpgradedCancelledEvent) {

}
func (v *Village) OnConstructionStarted(event *events.ConstructionStartedEvent) {

}
func (v *Village) OnConstructionFinished(event *events.ConstructionFinishedEvent) {

}
func (v *Village) OnConstructionCancelled(event *events.ConstructionCancelledEvent) {

}
func (v *Village) OnBuildingUpgradeStarted(event *events.BuildingUpgradeStartedEvent) {

}
func (v *Village) OnBuildingUpgradeFinished(event *events.BuildingUpgradeFinishedEvent) {
	v.levels[event.TileID]++
}
func (v *Village) OnBuildingUpgradeCancelled(event *events.BuildingUpgradeCancelledEvent) {

}
func (v *Village) OnResearchStarted(event *events.ResearchStartedEvent) {

}
func (v *Village) OnResearchCompleted(event *events.ResearchCompletedEvent) {

}
func (v *Village) OnDemolitionStarted(event *events.DemolitionStartedEvent) {

}
func (v *Village) OnDemolitionCompleted(event *events.DemolitionCompletedEvent) {

}
func (v *Village) OnDemolitionCancelled(event *events.DemolitionCancelledEvent) {

}
func (v *Village) OnTradeofferPlaced(event *events.TradeofferPlacedEvent) {

}
func (v *Village) OnTradeofferAccepted(event *events.TradeofferAcceptedEvent) {

}
func (v *Village) OnTradeofferCancelled(event *events.TradeofferCancelledEvent) {

}
func (v *Village) OnTradeofferArrived(event *events.TradeofferArrivedEvent) {

}
func (v *Village) OnTradeRouteCreated(event *events.TradeRouteCreatedEvent) {

}
func (v *Village) OnTradeRouteExecuted(event *events.TradeRouteExecutedEvent) {

}
func (v *Village) OnTradeRouteStopped(event *events.TradeRouteStoppedEvent) {

}
func (v *Village) OnTradeRouteStopped(event *events.TradeRouteStoppedEvent) {

}
func (v *Village) OnCelebrationStarted(event *events.CelebrationStartedEvent) {
	v.celebrationOngoing = true
}
func (v *Village) OnCelebrationCompleted(event *events.CelebrationCompletedEvent) {
	v.celebrationOngoing = false
}

func (v *Village) OnGoldCompleted(event *events.GoldCompletionEvent) {
	v.celebrationOngoing = false
}

func (v *Village) OnPlusStarted(event *events.GoldCompletionEvent) {
	v.ConcurrentConstructionsAllowed += 1
}
